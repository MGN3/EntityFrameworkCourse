# Entity Framework fundamentals course
Tutorial minimal API: https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-7.0&preserve-view=true&tabs=visual-studio

Compatible with:

	1- SQL Server
	2- Azure SQL Database
	3- SQLite
	4- Azure Cosmos DB
	5- MySQL
	6- PostgreSQL
	7- Other DBMS using an API plugin.

## Main concepts

- Entity framework is an ORM .NET open source framework.
- ADO.NET is used by EF internally. It's a group of libraries for database conectivity and more(excel, access, sql server). With ado.net we can connect to different data sources with a common interface. Entity framework works over that ado.net layer, as well as using datasets or linq to sql.

### Database main challenges(ORM Object Relational Mapping)
Examples: Hibernate(java), Dapper, NHibernate(version for .NET), Django ORM(python).

- Keeping up the database schema/structure
- Create SQL queries
- Transform data and data types in the backend programs to make them usable
- Guarantee the security.

![ado.net](https://static.platzi.com/media/user_upload/3-ADO.NET-6ec83b31-1eaa-4a82-98e7-3ccba8401cb5.jpg)

## ORM and direct SQL(hybrid strategy)

Using an ORM as a base and resorting to direct SQL queries when necessary is a strategy that combines the best of both worlds.

**Initial Productivity:** ORMs are great for speeding up initial application development by providing a fast and consistent way to interact with the database.To focus on the logic of the application instead of worrying about low-level details of data access.

**Abstraction and Portability:** ORMs offer an abstraction layer that facilitates the portability of the application between different database management systems (DBMS). If you decide to change DBMSs in the future, you can adjust the ORM configuration instead of rewriting all data access.

**Code Consistency:** Using an ORM tends to produce more consistent and readable code, since it follows an object-oriented programming paradigm. This facilitates collaboration between developers and maintenance of code over time.

**Security:** ORMs often include mechanisms to prevent SQL injection and other security attacks, which improves application security.

**Scalability:** In most cases, ORMs are suitable for medium to large-sized applications. However, when a specific query requires detailed performance optimization or direct access to certain database features is needed, resorting to direct SQL can be a viable solution.

**Query Optimization:** In situations where the queries generated by the ORM do not meet performance requirements, you can use direct SQL to write specific, optimized queries that address performance issues.

**Flexibility:** Having the ability to use direct SQL when necessary provides additional flexibility and control over interaction with the database.

## EF key features

- Improves development speed
- Enables the use of a single repository
- Improves security
- Easier to program backends
- Control of the changes made in the database

## Data Annotations
The data annotations are metadata that apply to the properties of a class.
The metadata modify the behaviour of the properties in different ways as stated.

How to use them: 
```
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
```
```
[Required]
public string Nombre { get; set; }

[Key]
public Guid CategoryId { get; set; }

[StringLength(50, MinimumLength = 2)]
public string Descripcion { get; set; }

[Range(1, 100)]
public int Cantidad { get; set; }

[RegularExpression(@"^\d{5}$")]
public string CodigoPostal { get; set; }

[EmailAddress]
public string CorreoElectronico { get; set; }

[DataType(DataType.Date)]
public DateTime FechaNacimiento { get; set; }

[Display(Name = "Nombre del Producto")]
public string Nombre { get; set; }

[Compare("Password", ErrorMessage = "Las contraseñas no coinciden.")]
public string ConfirmarPassword { get; set; }
```

## Fluent API
It's can substitute the data annotations while keeping the "CODE FIRST" principle where 
the data properties of each column are declared in the program rather than the database trhough
SQL syntaxis.

The syntax is like "extension methods", chaining the different methods appliying to a table.

```
protected override void OnModelCreating(ModelBuilder modelBuilder) {
			modelBuilder.Entity<Category>(cat => {
				cat.ToTable("Category");
				cat.HasKey(p => p.CategoryId);
				cat.Property(p => p.Name).IsRequired().HasMaxLength(150);
				cat.Property(p => p.Description).HasMaxLength(500);
			});

			modelBuilder.Entity<Models.Task>(tasks => {
				tasks.ToTable("Task");
				tasks.HasKey(p => p.TaskId);
				tasks.HasOne(p => p.Category).WithMany(p => p.Tasks).HasForeignKey(p => p.CategoryId);
				tasks.Property(p => p.Title).IsRequired().HasMaxLength(200);
				tasks.Property(p => p.Description).HasMaxLength(500);
				tasks.Property(p => p.TaskPriority).IsRequired();
				tasks.Property(p => p.TaskCreated).IsRequired();
				tasks.Ignore(p => p.Resumen);

				tasks.Property(p => p.Category).HasConversion();

				...
				...
			});
```

Fluent API enables the fine tuning of the relations, constraints and properties of the tables and datafields.

### Fluent API vs Data Annotations

***FLUENT API Advantages***
**Better grouping and readability**: Fluent API and the extension methods are all in one single place: 
the OnModelCreating(ModelBuilder modelbuilder) Method.
**Flexibility**: Advanced mapping details, complex relationships, and customize specific behaviors.

***FLUENT API CONS***
**More complex**: Its verbose compared to Data Annotations, specially for simple configurations.
**Learning curve**: The Fluent API may have a steeper learning curve for new developers, as it requires familiarization with Entity Framework-specific methods and properties.

***Data Annotations Advantages***
**Simplified syntax**: the attributes for the class properties are set in the own class with simple keywords.
**Easy for begginners**: Easy to learn and use.
**Less code**: Sometimes it can be more adequate for basic configurations.

***Data Annotations CONS***
**Limitations**: Not adequate for advanced, customiced or complex configurations.
**Less modularity**: The annotations are in each class, which can make the unreadable.